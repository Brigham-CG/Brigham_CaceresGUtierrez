// compile: g++ -g -O2 -std=c++11 -pthread -march=native RSA.cpp RSAFun.cpp -o RSA -lntl -lgmp -lm
#include <iostream>
#include <NTL/ZZ.h>
#include "RSA.h"

using namespace std;
using namespace NTL;

int main(){
    
    cout <<"\n         ____  ____    _    \n";
    cout <<"        |  _ \\/ ___|  / \\   \n";
    cout <<"        | |_) \\___ \\ / _ \\  \n";
    cout <<"        |  _ < ___) / ___ \\ \n";
    cout <<"        |_| \\_\\____/_/   \\_\\ \n\n\n";
    int select = 0;
    cout << "1) Muestra\n";
    cout << "2) Enviar mensaje\n";
    cout << "3) Recibir mensaje\n";
    cout << "Seleccione: ";
    cin >> select;
    
    if (select == 1){

        int bits = 0;
        cout << "Ingrese la cantidad de bits: "; cin >> bits;
        cin.ignore();
        RSA receptor(bits);

        RSA emisor(bits);

        // examples:
        // "vis an alii graeci ne magna elitr ubique per mei te quis reque epicuri libris deleniti appareat vel et at tale labores urbanitas sit duo eu noster epicurei consetetur sea sumo principes adversarium an prima audire apeirian ut usu nonumy complectitur vix ad id duo vero etiam adversarium et aliquam scaevola adipiscing vis nam at case salutatus contentiones decore facilis appareat eu qui ne omnesque consequuntur vim eos an amet vocent mei ei feugait salutandi mel novum causae in pro id duis dolore incorrupte option equidem sed no vis nullam menandri ullamcorper at nullam vocent splendide ut vel"
        // "el unico sistema completamente seguro es aquel que esta apagado encerrado en un bloque de cemento y sellado en una habitacion rodeada de alambradas y guardias armados"
        receptor.establecer(emisor.getE(), emisor.getN());
        emisor.establecer(receptor.getE(), receptor.getN());
        // string mensaje = "el unico sistema completamente seguro es aquel que esta apagado encerrado en un bloque de cemento y sellado en una habitacion rodeada de alambradas y guardias armados";
        string mensaje = "The idea of an asymmetric public-private key cryptosystem is attributed to Whitfield Diffie and Martin Hellman, who published this concept in 1976. They also introduced digital signatures and attempted to apply number theory. Their formulation used a shared-secret-key created from exponentiation of some number, modulo a prime number. However, they left open the problem of realizing a one-way function, possibly because the difficulty of factoring was not well-studied at the time.[4]Ron Rivest, Adi Shamir, and Leonard Adleman at the Massachusetts Institute of Technology, made several attempts over the course of a year to create a one-way function that was hard to invert. Rivest and Shamir, as computer scientists, proposed many potential functions, while Adleman, as a mathematician, was responsible for finding their weaknesses. They tried many approaches including knapsack-based and permutation polynomials. For a time, they thought what they wanted to achieve was impossible due to contradictory requirements.[5] In April 1977, they spent Passover at the house of a student and drank a good deal of Manischewitz wine before returning to their homes at around midnight.[6] Rivest, unable to sleep, lay on the couch with a math textbook and started thinking about their one-way function. He spent the rest of the night formalizing his idea, and he had much of the paper ready by daybreak. The algorithm is now known as RSA the initials of their surnames in same order as their paper.[7]Clifford Cocks, an English mathematician working for the British intelligence agency Government Communications Headquarters (GCHQ), described an equivalent system in an internal document in 1973.[8] However, given the relatively expensive computers needed to implement it at the time, it was considered to be mostly a curiosity and, as far as is publicly known, was never deployed. His discovery, however, was not revealed until 1997 due to its top-secret classification.Kid-RSA (KRSA) is a simplified public-key cipher published in 1997, designed for educational purposes. Some people feel that learning Kid-RSA gives insight into RSA and other public-key ciphers, analogous to simplified DES.[9][10][11][12][13]A patent describing the RSA algorithm was granted to MIT on 20 September 1983 U.S. Patent 4,405,829 Cryptographic communications system and method. From DWPIs abstract of the patentThe system includes a communications channel coupled to at least one terminal having an encoding device and to at least one terminal having a decoding device. A message-to-be-transferred is enciphered to ciphertext at the encoding terminal by encoding the message as a number M in a predetermined set. That number is then raised to a first predetermined power (associated with the intended receiver) and finally computed. The remainder or residue, C, is... computed when the exponentiated number is divided by the product of two predetermined prime numbers (associated with the intended receiver).A detailed description of the algorithm was published in August 1977, in Scientific Americans Mathematical Games column.[7] This preceded the patents filing date of December 1977. Consequently, the patent had no legal standing outside the United States. Had Cockss work been publicly known, a patent in the United States would not have been legal either.When the patent was issued, terms of patent were 17 years. The patent was about to expire, on 21 September 2000, when RSA Security released the algorithm to the public domain, on 6 September 2000.[14]There are a number of attacks against plain RSA as described below.When encrypting with low encryption exponents (e.g., e  3) and small values of the m, (i.e., m <n1e) the result of me is strictly less than the modulus n. In this case, ciphertexts can be decrypted easily by taking the eth root of the ciphertext over the integers.If the same clear text message is sent to e or more recipients in an encrypted way, and the receivers share the same exponent e, but different p, q, and therefore n, then it is easy to decrypt the original clear text message via the Chinese remainder theorem. Johan Hastad noticed that this attack is possible even if the cleartexts are not equal, but the attacker knows a linear relation between them.[22] This attack was later improved by Don Coppersmith (see Coppersmiths attack).[23]Because RSA encryption is a deterministic encryption algorithm (i.e., has no random component) an attacker can successfully launch a chosen plaintext attack against the cryptosystem, by encrypting likely plaintexts under the public key and test if they are equal to the ciphertext. A cryptosystem is called semantically secure if an attacker cannot distinguish two encryptions from each other, even if the attacker knows (or has chosen) the corresponding plaintexts. As described above, RSA without padding is not semantically secure.[24]RSA has the property that the product of two ciphertexts is equal to the encryption of the product of the respective plaintexts. That is m1em2e  (m1m2)e (mod n). Because of this multiplicative property a chosen-ciphertext attack is possible. E.g., an attacker who wants to know the decryption of a ciphertext c  me (mod n) may ask the holder of the private key d to decrypt an unsuspicious-looking ciphertext c  cre (mod n) for some value r chosen by the attacker. Because of the multiplicative property c is the encryption of mr (mod n). Hence, if the attacker is successful with the attack, they will learn mr (mod n) from which they can derive the message m by multiplying mr with the modular inverse of r modulo n.[citation needed]Given the private exponent d one can efficiently factor the modulus n  pq. And given factorization of the modulus n  pq, one can obtain any private key (d,n) generated against a public key (e,n).[15]To avoid these problems, practical RSA implementations typically embed some form of structured, randomized padding into the value m before encrypting it. This padding ensures that m does not fall into the range of insecure plaintexts, and that a given message, once padded, will encrypt to one of a large number of different possible ciphertexts.Standards such as PKCS1 have been carefully designed to securely pad messages prior to RSA encryption. Because these schemes pad the plaintext m with some number of additional bits, the size of the un-padded message M must be somewhat smaller. RSA padding schemes must be carefully designed so as to prevent sophisticated attacks that may be facilitated by a predictable message structure. Early versions of the PKCS1 standard (up to version 1.5) used a construction that appears to make RSA semantically secure. However, at Crypto 1998, Bleichenbacher showed that this version is vulnerable to a practical adaptive chosen ciphertext attack. Furthermore, at Eurocrypt 2000, Coron et al.[25] showed that for some types of messages, this padding does not provide a high enough level of security. Later versions of the standard include Optimal Asymmetric Encryption Padding (OAEP), which prevents these attacks. As such, OAEP should be used in any new application, and PKCS1 v1.5 padding should be replaced wherever possible. The PKCS1 standard also incorporates processing schemes designed to provide additional security for RSA signatures, e.g. the Probabilistic Signature Scheme for RSA (RSA-PSS).Secure padding schemes such as RSA-PSS are as essential for the security of message signing as they are for message encryption. Two USA patents on PSS were granted (USPTO 6266771 and USPTO 70360140) however, these patents expired on 24 July 2009 and 25 April 2010, respectively. Use of PSS no longer seems to be encumbered by patents.[original research] Note that using different RSA key-pairs for encryption and signing is potentially more secure.[26]";
        getline(cin, mensaje);

        cout << "\nMensaje cifrado\n";
        string mensajeCifrado = emisor.cifrar(mensaje);
        string firma = emisor.firma_digital_cifrado(emisor.leer_datos("firma.txt"));

        cout << "Emisor: " << mensajeCifrado << endl;
        cout << "Firma: " << firma << endl; 

        cout << "\nMensaje descifrado\n";
        string mensajeDescifrado = receptor.descifrar(mensajeCifrado);
        string firmaDescifrada = receptor.firma_digital_descifrado(firma);

        cout << "Receptor: " << "'" << mensajeDescifrado <<"'"<< endl;
        cout << "Firma: " << "'" << firmaDescifrada << "'" << endl;
    }   
    else if(select == 2)
    {
        int bits = 0;
        cout << "Ingrese la cantidad de bits: "; cin >> bits;

        ZZ e, N;
        cout << "Receptor e: ";cin >> e;
        cout << "Receptor N: ";cin >> N;

        cin.ignore();
        RSA emisor(bits);
        emisor.establecer(e, N);
        string mensaje;
        getline(cin, mensaje);
        string mensajeCifrado = emisor.cifrar(mensaje);
        string firma = emisor.firma_digital_cifrado(emisor.leer_datos("firma.txt"));
        cout << "Mensaje cifrado: " << mensaje << endl;
        cout << "Emisor: " << mensajeCifrado << endl;
        cout << "Firma: " << firma << endl; 

    }
    else if(select == 3)
    {
        
        int bits = 0;
        cout << "Ingrese la cantidad de bits\n"; cin >> bits;
    
        RSA receptor(bits);
        cout << "e: " << receptor.getE() << endl;
        cout << "n: " << receptor.getN() << endl;

        ZZ e, N;
        cout << "Emisor e:";cin >> e;
        cout << "Emisor N: ";cin >> N;
        receptor.establecer(e, N);

        cin.ignore();
        string mensaje;
        cout << "Mensaje cifrado: ";
        getline(cin, mensaje);
        string firma;

        cout << "Firma: ";
        getline(cin, firma);

        cout << "Mensaje descifrado: " <<receptor.descifrar(mensaje) << endl;
        cout << "Firma: " << receptor.firma_digital_descifrado(firma) << endl;
    }

    // prueba en clase
    // ZZ p, q, e, d;
    // p = conv<ZZ>("154094845570608329244966631943657424988439146164810466685246837819684977755667016681320388705890945713897689084846266360790476421910349906754958317241576483319619059781860384893887075155557610125048573447294859154768251676146238176327576949477213016447428592859161284383785030447221785927790868405550701925987");
    // q = conv<ZZ>("128806997512276380317742296866215616844564248861112407754948608397347288620856451888818193478510413516777019353847348214484716564144014289518157725737524524585222132654839961842249764352034728838246720346430597647739158047868530257931480892296340559785257747808731348570204867482458486671397220530726596121181");
    // e = conv<ZZ>("125785490430896920479115795429775514149851932216997344242679273584202881615657523588016698045293432423714800316700353368431454560307574449611123443193837599044715201391536033640958331085066725474076480680823223810304692493174491487847247423800246008713627131777107618098848820568724081440767484666511189855127");
    // d = conv<ZZ>("548270001696161514146033910192230924228886653642375213994639481610864817702403995950812614899487586750910567102381360876421398257607337007696211991807139988301211254033232901613605005574747738106077567113281154402175112378780618188522692516376828830757359038573689538114492834265600163760424089405058708840354901445282326653735706718910864204325170362639906591100987114589339481487680394356595034055272116302884161491673596204895352468063927349622758933096742467472751115112457591432155527854531189800347115766196227179001484018549384258437636689588928152876863103254295803022636671722865559862196944707866997460743");
    // RSA emisor(p,q,e,d);
    // ZZ eR, nR;
    // eR = conv<ZZ>("56929083999869128637529205328995566080930925435432904160743742733906499268457492495262590316826104253122770786627540978511417165036400930802520769568593176540166065007492755865658370726971595274607610979595744824712837069733224299703999688501061917879572140126280203102544805077619490165215582971096827140195");
    // nR = conv<ZZ>("158152612832150782576293676104798521508904500455042997084051324066734569772057820190709426359619927274127118509657269054915331134637824363444862989691781323898760411328591170361503644402370376627394872607099172951704157217580780868057712834559861035012800272893676229847714317400059290126242887021675898264843");
    // emisor.establecer(eR, nR);

    // cin.ignore();
    // string mensaje;
    // cout << "mensaje: ";
    // getline(cin, mensaje);
    // cout << "cifrado: " << emisor.cifrar(mensaje) << endl;
    // cout << "firma: " << emisor.firma_digital_cifrado(emisor.leer_datos("firma.txt")) << endl;

    // cout << "descifrar: " << emisor.descifrar("063870701116849593932811874683252649868099648203313938744967871924243130858391923028222292177466587173173656063490025429005739868458740349053494844335711448628458304853150301420977805419094935334054959357199894415156544920828934781087965420399098650622934046181060353111398063901316830946051616280432659102904935356061328496534382915872484449505686722515860196328555573107469294249924351226972923015347802217318596159292936897729061180038385558834651444868527123535277450919659383877647089478710898010031307786845274701778531233188994587258070959949764963847211468921787044911843720242577359227459204456015184969713400168049326760941620165860521314776369640967473189028455288504889174756559623433933137068094330786218246790557857230041576462891355548603427511073340281193965704075164897356313505838895413750318504339617588784556602380482020594087421860529611479860498179467057844694979502129728192698654428305543174027002272391736456452402894354174308686121001692357059715988106201357019926304213012005748692965414090679300620860825734484616040903993819457223269106637078292497961284837573133110931538340765452247170663094555917409604649707205604981900111070545645372411951663527925715466456263506314903482046680221786322799166054163405140480633111194130520512570130118348466343354329232759443208348816187181884101604865762721138839032181049175300562437818692560683487205044883290804892301108523338920290875354327942726185942654821655521450725298341796179268056711635266140754145728215859386804182372573919862153767959025474784737495273611365745862318286597247578099580171214308289882967591423404692845491253960761891402464197782825753174688460397427785985691896632573633871639706803704320165457009112639781647444732917668869757221495633381604842808064419109683658595526695937140543215183545323415649456170838164790401870551121549921798218726605262875072258350415351310738421317368544084086427255921829746013774547210925877889946224036615320142654920276497820134444026662973823120430246585534080273538791921085327708818774153250551608342040366922767391329606850799810674364286802035637099232290387446292892734533780934232632341538546708672159877043687269856661921201453159875401606516668159289244802974883675642186228930764234111715136170367712054196908960250874965091129710103758316054526812220083457409263327097214644780116999594248892985338639418835359940372462066144947011321618887965251200343048547728201393920177241396917883043677425097717936429134933918471873931222094295426527223121472690230324796604934527093378538218778155733971560788123231194358744967931798609860501493201285746013473849201203166414890149845324482581261459240227848027222325003101908307670337070446045309110416150244882145437749781661487937176922636579786770000398673512132858317596070594021318106590382770384894298851078680724361877877510276987161985251054909748018917936203778607951197125506381666274768230758882729064593635610840230733338343573640665624486421801820532451683392899970987327342213533875490446893255763145091500632777531133511984515687519415087639678858609986355747417355031176752633024316618367909717478034411572260539415591934754368935223265697478943370863505761363239549474565260758130318038339701100880264989137158067246099648012118358597488895736573339468065309338188620573261125056071639155544620547995863419657362667022322138335705215005665485322798386219851289608694934391043081786083221888253209592193645050469713731046635891417110931929741736215315220307019076384923461969033141497745960363487719762907085352143907871648919991898017963791293086342193180854953297605279058431030294197345221977120418110430417645979802502636699601599546773809169635612903138329027651682144466557778726751221872731668097135264671282034584478745199185556577866936078898994276272574830995772880347315560577265677130986849749355794162956972957191798547430443559962131142877523224021268104144611928860534317112860490653984101753959942007549152432282134826314172525358635995297794688531891611883067614259502255462291018765211761197175378621232943150374041042492444722413680115105608088880267614181833236432358401743120039543763470952249854032549422901269990882994230489240085673538613881737313134143949097861310074775492649350602748404112715120636104904997515163121625513599333467532305585197750285111036912627487648555485886058279123336261793291353418147113910763060234367442605023515351974102109527965448308840882017392048582989703445883824644722228648295001315524119790575801941422613849182492222351994960872261281859355995612049052189628775416512350377486047153289902564172365714302106355847950110161314183824930877982394586760827911777351235479504038403379279545272286520978973580119724579577859330169197633020555229917230931291896911325607534705939719073094866645587034163158797263158686272002875123004619501652295491478635815401357441679035694122174248135321418353905180249618813904417958798241410260559754352687693427896632337368943757059931205710915920944781886607904966604106960045171457901433713379499046983205263738512157961181529140297225444378467619715041144374693848362336948163391466230760516771967393541738715100836091277140357065599784080582504660613555689198586346380678739438833923729620702432903788096981297353791780003428215391710774092881683899570357927138103634939547320231945798221466479378003924175674338515657252665258753477418293539754209278065187724290461627481815442406516847440705144816333766976969839039661766648458350979219721464892444997944995247328769452916495456213896745029659684938941087311052753080804225544423145532151038681964869573155205408959940048039493747577990295461963431513243147528922905717076527363402494939739179416958368851552460451761167563362329616642918142766049040059054725235379934057277158544861827043262099303619953243838148803703991403554595846639652659840793072138584436201712682625112024793099921578915990139135293291791809659174685090003402060910332456659996391155063785053694928833845974668786119474422005015639580499149436052918439071494761239769442498578355190224319959201091104520628888304396594424975470914454943503514188855745772796066006195374931451332799138706696952279225283014361666265982100212160037973818605160811340678279510698351679898020402448743811301450862484971675362691573477948758289022532660369639404789401596524172258779081593425346992389652539534942889428680473589513152096347476053697966273432478258722355357614197343095513026104184031765837870510190805880002398940023928225979691084511707674173496884808616998835804843042736445678637215340640665860283644845020432801705062277473404133617494202969248182552296049125635135772511898673009294775555126238541132208892806911636783028951146939722981357919834380495196457022505456072056142553680711661190339314092735929017119152920468932345306097497773407272211227623716165716809484495786310815220550269405283214001088924906494168482929467700429141128912178239518671392831830839938617212508857844057176544351901226930592679426509398409375452038808409737350767340751645149671899713568511942539178640769973212859296890893472984130986678745232910589465577242894195751718334974743977959516018732812835305279692872216418719020215103178668647218223073753091117895612386567594868265084693455111829711707281692456076572724173515323927157456765525285300676751295904041365573919738052227317553541404910346882762486260415384263363271070902437851157104767808403431472550636588712033099257425261976335387570076850999545345374906837261035190075374216244543533992305932445002259722905434377908893308584656361376948689377081387578747913167464324409732666986980919932882224328428696572245856881835020099938254363812922726798258752332810320575306159442766906574032702431982736088624890976719477333904802560666712561270488985579941425184610527526668550310955679336402367742130328238299382604333382746407661455931131855289058787660001221331905414540051030259309558572746897131993114773579998704165221563127785561963175189538996401398118644101931591057787430118371638916149114232018303186128385140600810071651690760592787475231307311593896897897209410089167502326784192892044767537489841139950625572113594725461988782796405612760843414933425240049243693093066437559336637202110297458008211821739879538447586865300530528899086206376801215424141086931970448828625760507608206392260164287317232166791522416033523813615921688278175505645884482108230498147639013406727385399167383616175220885173230782277677799706109914052344456772122386722008442397932324306414301164174277388010640796908264001667614345929762355350299438974177875138866331937075856526870930459761190736830262677739620796678954666646490690890741973948426393501048183756973584910004600885003589163437299515687040122214468172998858042128796671257203794235355470599634742684343443789513805384464512855056927059236253306681811650598204938979671535523104813119789388733961572211294357855371218026028415882625694690809935542471399815566396054390723338093922985843853746603577336804341878592148376246036794637769013201693066198460366449921477716068989779854785339324192686152836159857338770097917030036111489124848946760629746237132498034827558636698481351854892895402406707614483123088672776659822394111368062454105824494869931797252729711216403773549554594424585369629223740192122234680488371539395681947025280");
    // cout << "descifrar firma: " << emisor.firma_digital_descifrado  ("13539586243283168917591518953407205742662589173219372292806063839587383479457559076992577596765040684128088334368657462523326820239437466292523052979985869225074049935019710376576152662297928295879275735501501160102536532311226952751105798518749072503728832654218847106426467799510188968947134621061823083297932178818181350727351535271678550725616102187035369198675649215877477748944380070258658798287142677998915775849541546560810881558674515560199256995688624608219806357326604081627108533268604611491331117967221874985723855058401096728990523073193455554295732295441887129783607709911193076760894593954975034016842") << endl;
    // cout << "descifrar firma: " << emisor.decipherSwap("13539586243283168917591518953407205742662589173219372292806063839587383479457559076992577596765040684128088334368657462523326820239437466292523052979985869225074049935019710376576152662297928295879275735501501160102536532311226952751105798518749072503728832654218847106426467799510188968947134621061823083297932178818181350727351535271678550725616102187035369198675649215877477748944380070258658798287142677998915775849541546560810881558674515560199256995688624608219806357326604081627108533268604611491331117967221874985723855058401096728990523073193455554295732295441887129783607709911193076760894593954975034016842" ) << endl;
}